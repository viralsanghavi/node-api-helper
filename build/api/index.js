"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = exports.getJsonString = exports.getFormattedDate = exports.getPaginationParams = exports.checkMissingKeys = exports.formatInsertQueryValues = exports.getUpdateQuerySetClauseFormat = exports.getResponse = exports.DATE_TIME_FORMAT = exports.PAGINATION = exports.DATABASE_TRANSACTION_TYPES = exports.HTTP_STATUS_CODES = void 0;
// import {createHmac} from "crypto";
const moment_1 = __importDefault(require("moment"));
exports.HTTP_STATUS_CODES = {
    OK: 200,
    CREATED: 201,
    ACCEPTED: 202,
    NO_CONTENT: 204,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    REQUEST_TIMEOUT: 408,
    INTERNAL_SERVER_ERROR: 500,
    BAD_GATEWAY: 502,
    SERVICE_UNAVAILABLE: 503,
    GATEWAY_TIMEOUT: 504,
};
exports.DATABASE_TRANSACTION_TYPES = {
    BEGIN: "BEGIN",
    COMMIT: "COMMIT",
    ROLLBACK: "ROLLBACK",
};
exports.PAGINATION = {
    MIN_LIMIT: 1,
    MAX_LIMIT: 100,
    LIMIT: 20,
    DEFAULT_PAGE: 1,
};
exports.DATE_TIME_FORMAT = "YYYY-MM-DD HH:mm:ss.SSS";
const getResponse = (obj = { message: "Bad Request" }, statusCode = exports.HTTP_STATUS_CODES.BAD_REQUEST, contentType = "application/json") => {
    let resMessage = {
        body: JSON.stringify(obj),
        statusCode: statusCode,
        isBase64Encoded: false,
        headers: {
            contentType,
        },
    };
    return resMessage;
};
exports.getResponse = getResponse;
/**
 * @description function creates a comma separated format of keys and values to use in set clause of update queries
 * @param {*} keyValueObject
 * @returns string
 * @example
 * keyValueObject: {"key1": value1, "key2": value2}
 * output: "key1=value1, key2=value2"
 */
const getUpdateQuerySetClauseFormat = (keyValueObject) => {
    if (!keyValueObject || typeof keyValueObject !== "object") {
        throw new Error("Object type is required");
    }
    return Object.entries(keyValueObject)
        .map(([key, value]) => `${key}='${value}'`)
        .join(", ");
};
exports.getUpdateQuerySetClauseFormat = getUpdateQuerySetClauseFormat;
/**
 * @description: function creates a comma-separated string of quoted values that can be used for passing inside insert queries.
 * @param {*} fieldArray
 * @returns string
 * @example
 * fieldArray: ["person1", 26, 9876543210]
 * output: "'person1', '26', '9876543210'"
 */
const formatInsertQueryValues = (fieldArray) => {
    if (!Array.isArray(fieldArray)) {
        throw new Error("Array is required");
    }
    return fieldArray.map((element) => `'${element}'`).join(",");
};
exports.formatInsertQueryValues = formatInsertQueryValues;
/**
 * @description function compares two arrays and returns keys from first array which are not available in second array
 * @param {*} requiredList array
 * @param {*} availableList array
 * @returns array
 * @example
 * requiredList: ["one", "two"]
 * availableList: ["two", "three"]
 * returns ["one"]
 */
const checkMissingKeys = (requiredList = [], availableList = []) => {
    if (!Array.isArray(requiredList) || !Array.isArray(availableList)) {
        throw new Error("Required and Available List must be an array");
    }
    return requiredList.filter((element) => availableList.indexOf(element) < 0);
};
exports.checkMissingKeys = checkMissingKeys;
// /**
//  * @description function hashes numbers and strings.
//  * @param {*} dataString string | number
//  * @param {*} salt
//  * @returns string
//  */
// export const createHash = (dataString: string, salt: string): string => {
//   if (typeof dataString !== "string") {
//     throw new Error("String type is required");
//   }
//   const hmac = createHmac("sha256", salt);
//   return hmac.update(dataString).digest("hex");
// };
/**
 *
 * @param {*} limit
 * @param {*} page
 * @returns { limit: number, offset: number }
 */
const getPaginationParams = (limit, page) => {
    const { LIMIT, MIN_LIMIT, MAX_LIMIT, DEFAULT_PAGE } = exports.PAGINATION;
    if (typeof limit !== "number") {
        limit = LIMIT;
    }
    else {
        if (limit < MIN_LIMIT) {
            limit = MIN_LIMIT;
        }
        if (limit > MAX_LIMIT) {
            limit = MAX_LIMIT;
        }
    }
    if (typeof page !== "number" || page < DEFAULT_PAGE) {
        page = DEFAULT_PAGE;
    }
    const offset = (page - 1) * limit;
    return { limit, offset };
};
exports.getPaginationParams = getPaginationParams;
/**
 * @description returns passed date or current date into required passed format
 * @param {*} format
 * @param {*} date
 * @returns string
 */
const getFormattedDate = (format, date) => {
    if (date) {
        return (0, moment_1.default)(date).format(format);
    }
    return (0, moment_1.default)().format(format);
};
exports.getFormattedDate = getFormattedDate;
const getJsonString = (str) => {
    try {
        if (str.toString() === "null")
            throw new Error();
        return JSON.parse(str);
    }
    catch (e) {
        return {};
    }
};
exports.getJsonString = getJsonString;
const isObject = function (obj) {
    return obj === Object(obj) && !(0, exports.isArray)(obj) && typeof obj !== "function";
};
const isArray = function (array) {
    return Array.isArray(array);
};
exports.isArray = isArray;
const toCamel = (str) => {
    return str.replace(/([-_][a-z])/gi, ($1) => {
        return $1.toUpperCase().replace("-", "").replace("_", "");
    });
};
// export const keysToCamel = function (obj: any): any {
//   if (isObject(obj)) {
//     const n = {};
//     Object.keys(obj).forEach((key) => {
//       n[toCamel(key)] = keysToCamel(obj[key]);
//     });
//     return n;
//   } else if (isArray(obj)) {
//     return obj.map((index) => {
//       return keysToCamel(index);
//     });
//   }
//   return obj;
// };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXBpL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHFDQUFxQztBQUNyQyxvREFBNEI7QUFFZixRQUFBLGlCQUFpQixHQUFHO0lBQy9CLEVBQUUsRUFBRSxHQUFHO0lBQ1AsT0FBTyxFQUFFLEdBQUc7SUFDWixRQUFRLEVBQUUsR0FBRztJQUNiLFVBQVUsRUFBRSxHQUFHO0lBQ2YsV0FBVyxFQUFFLEdBQUc7SUFDaEIsWUFBWSxFQUFFLEdBQUc7SUFDakIsU0FBUyxFQUFFLEdBQUc7SUFDZCxTQUFTLEVBQUUsR0FBRztJQUNkLGVBQWUsRUFBRSxHQUFHO0lBQ3BCLHFCQUFxQixFQUFFLEdBQUc7SUFDMUIsV0FBVyxFQUFFLEdBQUc7SUFDaEIsbUJBQW1CLEVBQUUsR0FBRztJQUN4QixlQUFlLEVBQUUsR0FBRztDQUNyQixDQUFDO0FBRVcsUUFBQSwwQkFBMEIsR0FBRztJQUN4QyxLQUFLLEVBQUUsT0FBTztJQUNkLE1BQU0sRUFBRSxRQUFRO0lBQ2hCLFFBQVEsRUFBRSxVQUFVO0NBQ3JCLENBQUM7QUFFVyxRQUFBLFVBQVUsR0FBRztJQUN4QixTQUFTLEVBQUUsQ0FBQztJQUNaLFNBQVMsRUFBRSxHQUFHO0lBQ2QsS0FBSyxFQUFFLEVBQUU7SUFDVCxZQUFZLEVBQUUsQ0FBQztDQUNoQixDQUFDO0FBRVcsUUFBQSxnQkFBZ0IsR0FBRyx5QkFBeUIsQ0FBQztBQUVuRCxNQUFNLFdBQVcsR0FBRyxDQUN6QixNQUFXLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBQyxFQUNuQyxhQUFxQix5QkFBaUIsQ0FBQyxXQUFXLEVBQ2xELGNBQXNCLGtCQUFrQixFQU14QyxFQUFFO0lBQ0YsSUFBSSxVQUFVLEdBQUc7UUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7UUFDekIsVUFBVSxFQUFFLFVBQVU7UUFDdEIsZUFBZSxFQUFF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QU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUM7QUFGVyxRQUFBLE9BQU8sV0FFbEI7QUFFRixNQUFNLE9BQU8sR0FBRyxDQUFDLEdBQVcsRUFBVSxFQUFFO0lBQ3RDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRTtRQUN6QyxPQUFPLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDNUQsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUM7QUFFRix3REFBd0Q7QUFDeEQseUJBQXlCO0FBQ3pCLG9CQUFvQjtBQUVwQiwwQ0FBMEM7QUFDMUMsaURBQWlEO0FBQ2pELFVBQVU7QUFFVixnQkFBZ0I7QUFDaEIsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsVUFBVTtBQUNWLE1BQU07QUFFTixnQkFBZ0I7QUFDaEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCB7Y3JlYXRlSG1hY30gZnJvbSBcImNyeXB0b1wiO1xuaW1wb3J0IG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5cbmV4cG9ydCBjb25zdCBIVFRQX1NUQVRVU19DT0RFUyA9IHtcbiAgT0s6IDIwMCxcbiAgQ1JFQVRFRDogMjAxLFxuICBBQ0NFUFRFRDogMjAyLFxuICBOT19DT05URU5UOiAyMDQsXG4gIEJBRF9SRVFVRVNUOiA0MDAsXG4gIFVOQVVUSE9SSVpFRDogNDAxLFxuICBGT1JCSURERU46IDQwMyxcbiAgTk9UX0ZPVU5EOiA0MDQsXG4gIFJFUVVFU1RfVElNRU9VVDogNDA4LFxuICBJTlRFUk5BTF9TRVJWRVJfRVJST1I6IDUwMCxcbiAgQkFEX0dBVEVXQVk6IDUwMixcbiAgU0VSVklDRV9VTkFWQUlMQUJMRTogNTAzLFxuICBHQVRFV0FZX1RJTUVPVVQ6IDUwNCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRBQkFTRV9UUkFOU0FDVElPTl9UWVBFUyA9IHtcbiAgQkVHSU46IFwiQkVHSU5cIixcbiAgQ09NTUlUOiBcIkNPTU1JVFwiLFxuICBST0xMQkFDSzogXCJST0xMQkFDS1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFBBR0lOQVRJT04gPSB7XG4gIE1JTl9MSU1JVDogMSxcbiAgTUFYX0xJTUlUOiAxMDAsXG4gIExJTUlUOiAyMCxcbiAgREVGQVVMVF9QQUdFOiAxLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfVElNRV9GT1JNQVQgPSBcIllZWVktTU0tREQgSEg6bW06c3MuU1NTXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRSZXNwb25zZSA9IChcbiAgb2JqOiBhbnkgPSB7bWVzc2FnZTogXCJCYWQgUmVxdWVzdFwifSxcbiAgc3RhdHVzQ29kZTogbnVtYmVyID0gSFRUUF9TVEFUVVNfQ09ERVMuQkFEX1JFUVVFU1QsXG4gIGNvbnRlbnRUeXBlOiBzdHJpbmcgPSBcImFwcGxpY2F0aW9uL2pzb25cIlxuKToge1xuICBib2R5OiBzdHJpbmc7XG4gIHN0YXR1c0NvZGU6IG51bWJlcjtcbiAgaXNCYXNlNjRFbmNvZGVkPzogYm9vbGVhbjtcbiAgaGVhZGVyczogYW55O1xufSA9PiB7XG4gIGxldCByZXNNZXNzYWdlID0ge1xuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG9iaiksXG4gICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSxcbiAgICBpc0Jhc2U2NEVuY29kZWQ6IGZhbHNlLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIGNvbnRlbnRUeXBlLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiByZXNNZXNzYWdlO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gZnVuY3Rpb24gY3JlYXRlcyBhIGNvbW1hIHNlcGFyYXRlZCBmb3JtYXQgb2Yga2V5cyBhbmQgdmFsdWVzIHRvIHVzZSBpbiBzZXQgY2xhdXNlIG9mIHVwZGF0ZSBxdWVyaWVzXG4gKiBAcGFyYW0geyp9IGtleVZhbHVlT2JqZWN0XG4gKiBAcmV0dXJucyBzdHJpbmdcbiAqIEBleGFtcGxlXG4gKiBrZXlWYWx1ZU9iamVjdDoge1wia2V5MVwiOiB2YWx1ZTEsIFwia2V5MlwiOiB2YWx1ZTJ9XG4gKiBvdXRwdXQ6IFwia2V5MT12YWx1ZTEsIGtleTI9dmFsdWUyXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVwZGF0ZVF1ZXJ5U2V0Q2xhdXNlRm9ybWF0ID0gKGtleVZhbHVlT2JqZWN0OiBhbnkpOiBhbnkgPT4ge1xuICBpZiAoIWtleVZhbHVlT2JqZWN0IHx8IHR5cGVvZiBrZXlWYWx1ZU9iamVjdCAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCB0eXBlIGlzIHJlcXVpcmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGtleVZhbHVlT2JqZWN0KVxuICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fT0nJHt2YWx1ZX0nYClcbiAgICAuam9pbihcIiwgXCIpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb246IGZ1bmN0aW9uIGNyZWF0ZXMgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIG9mIHF1b3RlZCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgcGFzc2luZyBpbnNpZGUgaW5zZXJ0IHF1ZXJpZXMuXG4gKiBAcGFyYW0geyp9IGZpZWxkQXJyYXlcbiAqIEByZXR1cm5zIHN0cmluZ1xuICogQGV4YW1wbGVcbiAqIGZpZWxkQXJyYXk6IFtcInBlcnNvbjFcIiwgMjYsIDk4NzY1NDMyMTBdXG4gKiBvdXRwdXQ6IFwiJ3BlcnNvbjEnLCAnMjYnLCAnOTg3NjU0MzIxMCdcIlxuICovXG5leHBvcnQgY29uc3QgZm9ybWF0SW5zZXJ0UXVlcnlWYWx1ZXMgPSAoZmllbGRBcnJheTogYW55KTogYW55ID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpZWxkQXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgaXMgcmVxdWlyZWRcIik7XG4gIH1cblxuICByZXR1cm4gZmllbGRBcnJheS5tYXAoKGVsZW1lbnQpID0+IGAnJHtlbGVtZW50fSdgKS5qb2luKFwiLFwiKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIGZ1bmN0aW9uIGNvbXBhcmVzIHR3byBhcnJheXMgYW5kIHJldHVybnMga2V5cyBmcm9tIGZpcnN0IGFycmF5IHdoaWNoIGFyZSBub3QgYXZhaWxhYmxlIGluIHNlY29uZCBhcnJheVxuICogQHBhcmFtIHsqfSByZXF1aXJlZExpc3QgYXJyYXlcbiAqIEBwYXJhbSB7Kn0gYXZhaWxhYmxlTGlzdCBhcnJheVxuICogQHJldHVybnMgYXJyYXlcbiAqIEBleGFtcGxlXG4gKiByZXF1aXJlZExpc3Q6IFtcIm9uZVwiLCBcInR3b1wiXVxuICogYXZhaWxhYmxlTGlzdDogW1widHdvXCIsIFwidGhyZWVcIl1cbiAqIHJldHVybnMgW1wib25lXCJdXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja01pc3NpbmdLZXlzID0gKFxuICByZXF1aXJlZExpc3QgPSBbXSxcbiAgYXZhaWxhYmxlTGlzdCA9IFtdXG4pOiBhbnkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocmVxdWlyZWRMaXN0KSB8fCAhQXJyYXkuaXNBcnJheShhdmFpbGFibGVMaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVpcmVkIGFuZCBBdmFpbGFibGUgTGlzdCBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmVkTGlzdC5maWx0ZXIoKGVsZW1lbnQpID0+IGF2YWlsYWJsZUxpc3QuaW5kZXhPZihlbGVtZW50KSA8IDApO1xufTtcblxuLy8gLyoqXG4vLyAgKiBAZGVzY3JpcHRpb24gZnVuY3Rpb24gaGFzaGVzIG51bWJlcnMgYW5kIHN0cmluZ3MuXG4vLyAgKiBAcGFyYW0geyp9IGRhdGFTdHJpbmcgc3RyaW5nIHwgbnVtYmVyXG4vLyAgKiBAcGFyYW0geyp9IHNhbHRcbi8vICAqIEByZXR1cm5zIHN0cmluZ1xuLy8gICovXG4vLyBleHBvcnQgY29uc3QgY3JlYXRlSGFzaCA9IChkYXRhU3RyaW5nOiBzdHJpbmcsIHNhbHQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4vLyAgIGlmICh0eXBlb2YgZGF0YVN0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuLy8gICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0eXBlIGlzIHJlcXVpcmVkXCIpO1xuLy8gICB9XG5cbi8vICAgY29uc3QgaG1hYyA9IGNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgc2FsdCk7XG4vLyAgIHJldHVybiBobWFjLnVwZGF0ZShkYXRhU3RyaW5nKS5kaWdlc3QoXCJoZXhcIik7XG4vLyB9O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IGxpbWl0XG4gKiBAcGFyYW0geyp9IHBhZ2VcbiAqIEByZXR1cm5zIHsgbGltaXQ6IG51bWJlciwgb2Zmc2V0OiBudW1iZXIgfVxuICovXG5leHBvcnQgY29uc3QgZ2V0UGFnaW5hdGlvblBhcmFtcyA9IChcbiAgbGltaXQ6IG51bWJlcixcbiAgcGFnZTogbnVtYmVyXG4pOiB7bGltaXQ6IG51bWJlcjsgb2Zmc2V0OiBudW1iZXJ9ID0+IHtcbiAgY29uc3Qge0xJTUlULCBNSU5fTElNSVQsIE1BWF9MSU1JVCwgREVGQVVMVF9QQUdFfSA9IFBBR0lOQVRJT047XG5cbiAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gXCJudW1iZXJcIikge1xuICAgIGxpbWl0ID0gTElNSVQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxpbWl0IDwgTUlOX0xJTUlUKSB7XG4gICAgICBsaW1pdCA9IE1JTl9MSU1JVDtcbiAgICB9XG5cbiAgICBpZiAobGltaXQgPiBNQVhfTElNSVQpIHtcbiAgICAgIGxpbWl0ID0gTUFYX0xJTUlUO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFnZSAhPT0gXCJudW1iZXJcIiB8fCBwYWdlIDwgREVGQVVMVF9QQUdFKSB7XG4gICAgcGFnZSA9IERFRkFVTFRfUEFHRTtcbiAgfVxuXG4gIGNvbnN0IG9mZnNldCA9IChwYWdlIC0gMSkgKiBsaW1pdDtcblxuICByZXR1cm4ge2xpbWl0LCBvZmZzZXR9O1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBwYXNzZWQgZGF0ZSBvciBjdXJyZW50IGRhdGUgaW50byByZXF1aXJlZCBwYXNzZWQgZm9ybWF0XG4gKiBAcGFyYW0geyp9IGZvcm1hdFxuICogQHBhcmFtIHsqfSBkYXRlXG4gKiBAcmV0dXJucyBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZvcm1hdHRlZERhdGUgPSAoZm9ybWF0OiBzdHJpbmcsIGRhdGU6IERhdGUpOiBzdHJpbmcgPT4ge1xuICBpZiAoZGF0ZSkge1xuICAgIHJldHVybiBtb21lbnQoZGF0ZSkuZm9ybWF0KGZvcm1hdCk7XG4gIH1cblxuICByZXR1cm4gbW9tZW50KCkuZm9ybWF0KGZvcm1hdCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SnNvblN0cmluZyA9IChzdHI6IHN0cmluZyk6IGFueSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKHN0ci50b1N0cmluZygpID09PSBcIm51bGxcIikgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuY29uc3QgaXNPYmplY3QgPSBmdW5jdGlvbiAob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaikgJiYgIWlzQXJyYXkob2JqKSAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCI7XG59O1xuXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IGZ1bmN0aW9uIChhcnJheTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFycmF5KTtcbn07XG5cbmNvbnN0IHRvQ2FtZWwgPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLV9dW2Etel0pL2dpLCAoJDEpID0+IHtcbiAgICByZXR1cm4gJDEudG9VcHBlckNhc2UoKS5yZXBsYWNlKFwiLVwiLCBcIlwiKS5yZXBsYWNlKFwiX1wiLCBcIlwiKTtcbiAgfSk7XG59O1xuXG4vLyBleHBvcnQgY29uc3Qga2V5c1RvQ2FtZWwgPSBmdW5jdGlvbiAob2JqOiBhbnkpOiBhbnkge1xuLy8gICBpZiAoaXNPYmplY3Qob2JqKSkge1xuLy8gICAgIGNvbnN0IG4gPSB7fTtcblxuLy8gICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4vLyAgICAgICBuW3RvQ2FtZWwoa2V5KV0gPSBrZXlzVG9DYW1lbChvYmpba2V5XSk7XG4vLyAgICAgfSk7XG5cbi8vICAgICByZXR1cm4gbjtcbi8vICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHtcbi8vICAgICByZXR1cm4gb2JqLm1hcCgoaW5kZXgpID0+IHtcbi8vICAgICAgIHJldHVybiBrZXlzVG9DYW1lbChpbmRleCk7XG4vLyAgICAgfSk7XG4vLyAgIH1cblxuLy8gICByZXR1cm4gb2JqO1xuLy8gfTtcbiJdfQ==