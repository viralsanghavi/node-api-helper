"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = exports.getJsonString = exports.getFormattedDate = exports.getPaginationParams = exports.checkMissingKeys = exports.formatInsertQueryValues = exports.getUpdateQuerySetClauseFormat = exports.getResponse = exports.DATE_TIME_FORMAT = exports.PAGINATION = exports.DATABASE_TRANSACTION_TYPES = exports.HTTP_STATUS_CODES = void 0;
// import {createHmac} from "crypto";
const moment_1 = __importDefault(require("moment"));
exports.HTTP_STATUS_CODES = {
    OK: 200,
    CREATED: 201,
    ACCEPTED: 202,
    NO_CONTENT: 204,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    REQUEST_TIMEOUT: 408,
    INTERNAL_SERVER_ERROR: 500,
    BAD_GATEWAY: 502,
    SERVICE_UNAVAILABLE: 503,
    GATEWAY_TIMEOUT: 504,
};
exports.DATABASE_TRANSACTION_TYPES = {
    BEGIN: "BEGIN",
    COMMIT: "COMMIT",
    ROLLBACK: "ROLLBACK",
};
exports.PAGINATION = {
    MIN_LIMIT: 1,
    MAX_LIMIT: 100,
    LIMIT: 20,
    DEFAULT_PAGE: 1,
};
exports.DATE_TIME_FORMAT = "YYYY-MM-DD HH:mm:ss.SSS";
const getResponse = (obj = { message: "Bad Request" }, statusCode = exports.HTTP_STATUS_CODES.BAD_REQUEST, contentType = "application/json") => {
    let resMessage = {
        body: JSON.stringify(obj),
        statusCode: statusCode,
        isBase64Encoded: false,
        headers: {
            contentType,
            "Content-Type": "application/json",
            Allow: "GET, OPTIONS, POST, PUT, DELETE",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "OPTIONS ,POST ,GET ,PUT ,DELETE",
        },
    };
    return resMessage;
};
exports.getResponse = getResponse;
/**
 * @description function creates a comma separated format of keys and values to use in set clause of update queries
 * @param {*} keyValueObject
 * @returns string
 * @example
 * keyValueObject: {"key1": value1, "key2": value2}
 * output: "key1=value1, key2=value2"
 */
const getUpdateQuerySetClauseFormat = (keyValueObject) => {
    if (!keyValueObject || typeof keyValueObject !== "object") {
        throw new Error("Object type is required");
    }
    return Object.entries(keyValueObject)
        .map(([key, value]) => `${key}='${value}'`)
        .join(", ");
};
exports.getUpdateQuerySetClauseFormat = getUpdateQuerySetClauseFormat;
/**
 * @description: function creates a comma-separated string of quoted values that can be used for passing inside insert queries.
 * @param {*} fieldArray
 * @returns string
 * @example
 * fieldArray: ["person1", 26, 9876543210]
 * output: "'person1', '26', '9876543210'"
 */
const formatInsertQueryValues = (fieldArray) => {
    if (!Array.isArray(fieldArray)) {
        throw new Error("Array is required");
    }
    return fieldArray.map((element) => `'${element}'`).join(",");
};
exports.formatInsertQueryValues = formatInsertQueryValues;
/**
 * @description function compares two arrays and returns keys from first array which are not available in second array
 * @param {*} requiredList array
 * @param {*} availableList array
 * @returns array
 * @example
 * requiredList: ["one", "two"]
 * availableList: ["two", "three"]
 * returns ["one"]
 */
const checkMissingKeys = (requiredList = [], availableList = []) => {
    if (!Array.isArray(requiredList) || !Array.isArray(availableList)) {
        throw new Error("Required and Available List must be an array");
    }
    return requiredList.filter((element) => availableList.indexOf(element) < 0);
};
exports.checkMissingKeys = checkMissingKeys;
// /**
//  * @description function hashes numbers and strings.
//  * @param {*} dataString string | number
//  * @param {*} salt
//  * @returns string
//  */
// export const createHash = (dataString: string, salt: string): string => {
//   if (typeof dataString !== "string") {
//     throw new Error("String type is required");
//   }
//   const hmac = createHmac("sha256", salt);
//   return hmac.update(dataString).digest("hex");
// };
/**
 *
 * @param {*} limit
 * @param {*} page
 * @returns { limit: number, offset: number }
 */
const getPaginationParams = (limit, page) => {
    const { LIMIT, MIN_LIMIT, MAX_LIMIT, DEFAULT_PAGE } = exports.PAGINATION;
    if (typeof limit !== "number") {
        limit = LIMIT;
    }
    else {
        if (limit < MIN_LIMIT) {
            limit = MIN_LIMIT;
        }
        if (limit > MAX_LIMIT) {
            limit = MAX_LIMIT;
        }
    }
    if (typeof page !== "number" || page < DEFAULT_PAGE) {
        page = DEFAULT_PAGE;
    }
    const offset = (page - 1) * limit;
    return { limit, offset };
};
exports.getPaginationParams = getPaginationParams;
/**
 * @description returns passed date or current date into required passed format
 * @param {*} format
 * @param {*} date
 * @returns string
 */
const getFormattedDate = (format, date) => {
    if (date) {
        return (0, moment_1.default)(date).format(format);
    }
    return (0, moment_1.default)().format(format);
};
exports.getFormattedDate = getFormattedDate;
const getJsonString = (str) => {
    try {
        if (str.toString() === "null")
            throw new Error();
        return JSON.parse(str);
    }
    catch (e) {
        return {};
    }
};
exports.getJsonString = getJsonString;
const isObject = function (obj) {
    return obj === Object(obj) && !(0, exports.isArray)(obj) && typeof obj !== "function";
};
const isArray = function (array) {
    return Array.isArray(array);
};
exports.isArray = isArray;
const toCamel = (str) => {
    return str.replace(/([-_][a-z])/gi, ($1) => {
        return $1.toUpperCase().replace("-", "").replace("_", "");
    });
};
// export const keysToCamel = function (obj: any): any {
//   if (isObject(obj)) {
//     const n = {};
//     Object.keys(obj).forEach((key) => {
//       n[toCamel(key)] = keysToCamel(obj[key]);
//     });
//     return n;
//   } else if (isArray(obj)) {
//     return obj.map((index) => {
//       return keysToCamel(index);
//     });
//   }
//   return obj;
// };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXBpL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHFDQUFxQztBQUNyQyxvREFBNEI7QUFFZixRQUFBLGlCQUFpQixHQUFHO0lBQy9CLEVBQUUsRUFBRSxHQUFHO0lBQ1AsT0FBTyxFQUFFLEdBQUc7SUFDWixRQUFRLEVBQUUsR0FBRztJQUNiLFVBQVUsRUFBRSxHQUFHO0lBQ2YsV0FBVyxFQUFFLEdBQUc7SUFDaEIsWUFBWSxFQUFFLEdBQUc7SUFDakIsU0FBUyxFQUFFLEdBQUc7SUFDZCxTQUFTLEVBQUUsR0FBRztJQUNkLGVBQWUsRUFBRSxHQUFHO0lBQ3BCLHFCQUFxQixFQUFFLEdBQUc7SUFDMUIsV0FBVyxFQUFFLEdBQUc7SUFDaEIsbUJBQW1CLEVBQUUsR0FBRztJQUN4QixlQUFlLEVBQUUsR0FBRztDQUNyQixDQUFDO0FBRVcsUUFBQSwwQkFBMEIsR0FBRztJQUN4QyxLQUFLLEVBQUUsT0FBTztJQUNkLE1BQU0sRUFBRSxRQUFRO0lBQ2hCLFFBQVEsRUFBRSxVQUFVO0NBQ3JCLENBQUM7QUFFVyxRQUFBLFVBQVUsR0FBRztJQUN4QixTQUFTLEVBQUUsQ0FBQztJQUNaLFNBQVMsRUFBRSxHQUFHO0lBQ2QsS0FBSyxFQUFFLEVBQUU7SUFDVCxZQUFZLEVBQUUsQ0FBQztDQUNoQixDQUFDO0FBRVcsUUFBQSxnQkFBZ0IsR0FBRyx5QkFBeUIsQ0FBQztBQUVuRCxNQUFNLFdBQVcsR0FBRyxDQUN6QixNQUFXLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBQyxFQUNuQyxhQUFxQix5QkFBaUIsQ0FBQyxXQUFXLEVBQ2xELGNBQXNCLGtCQUFrQixFQU14QyxFQUFFO0lBQ0YsSUFBSSxVQUFVLEdBQUc7UUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7UUFDekIsVUFBVSxFQUFFLFVBQVU7UUFDdEIsZUFBZSxFQUFF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T0FBTyxHQUFHLEtBQUssVUFBVSxDQUFDO0FBQzNFLENBQUMsQ0FBQztBQUVLLE1BQU0sT0FBTyxHQUFHLFVBQVUsS0FBVTtJQUN6QyxPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDOUIsQ0FBQyxDQUFDO0FBRlcsUUFBQSxPQUFPLFdBRWxCO0FBRUYsTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFXLEVBQVUsRUFBRTtJQUN0QyxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUU7UUFDekMsT0FBTyxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzVELENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDO0FBRUYsd0RBQXdEO0FBQ3hELHlCQUF5QjtBQUN6QixvQkFBb0I7QUFFcEIsMENBQTBDO0FBQzFDLGlEQUFpRDtBQUNqRCxVQUFVO0FBRVYsZ0JBQWdCO0FBQ2hCLCtCQUErQjtBQUMvQixrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DLFVBQVU7QUFDVixNQUFNO0FBRU4sZ0JBQWdCO0FBQ2hCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQge2NyZWF0ZUhtYWN9IGZyb20gXCJjcnlwdG9cIjtcbmltcG9ydCBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuXG5leHBvcnQgY29uc3QgSFRUUF9TVEFUVVNfQ09ERVMgPSB7XG4gIE9LOiAyMDAsXG4gIENSRUFURUQ6IDIwMSxcbiAgQUNDRVBURUQ6IDIwMixcbiAgTk9fQ09OVEVOVDogMjA0LFxuICBCQURfUkVRVUVTVDogNDAwLFxuICBVTkFVVEhPUklaRUQ6IDQwMSxcbiAgRk9SQklEREVOOiA0MDMsXG4gIE5PVF9GT1VORDogNDA0LFxuICBSRVFVRVNUX1RJTUVPVVQ6IDQwOCxcbiAgSU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG4gIEJBRF9HQVRFV0FZOiA1MDIsXG4gIFNFUlZJQ0VfVU5BVkFJTEFCTEU6IDUwMyxcbiAgR0FURVdBWV9USU1FT1VUOiA1MDQsXG59O1xuXG5leHBvcnQgY29uc3QgREFUQUJBU0VfVFJBTlNBQ1RJT05fVFlQRVMgPSB7XG4gIEJFR0lOOiBcIkJFR0lOXCIsXG4gIENPTU1JVDogXCJDT01NSVRcIixcbiAgUk9MTEJBQ0s6IFwiUk9MTEJBQ0tcIixcbn07XG5cbmV4cG9ydCBjb25zdCBQQUdJTkFUSU9OID0ge1xuICBNSU5fTElNSVQ6IDEsXG4gIE1BWF9MSU1JVDogMTAwLFxuICBMSU1JVDogMjAsXG4gIERFRkFVTFRfUEFHRTogMSxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX1RJTUVfRk9STUFUID0gXCJZWVlZLU1NLUREIEhIOm1tOnNzLlNTU1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0UmVzcG9uc2UgPSAoXG4gIG9iajogYW55ID0ge21lc3NhZ2U6IFwiQmFkIFJlcXVlc3RcIn0sXG4gIHN0YXR1c0NvZGU6IG51bWJlciA9IEhUVFBfU1RBVFVTX0NPREVTLkJBRF9SRVFVRVNULFxuICBjb250ZW50VHlwZTogc3RyaW5nID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbik6IHtcbiAgYm9keTogc3RyaW5nO1xuICBzdGF0dXNDb2RlOiBudW1iZXI7XG4gIGlzQmFzZTY0RW5jb2RlZD86IGJvb2xlYW47XG4gIGhlYWRlcnM6IGFueTtcbn0gPT4ge1xuICBsZXQgcmVzTWVzc2FnZSA9IHtcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvYmopLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsXG4gICAgaXNCYXNlNjRFbmNvZGVkOiBmYWxzZSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBjb250ZW50VHlwZSxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgQWxsb3c6IFwiR0VULCBPUFRJT05TLCBQT1NULCBQVVQsIERFTEVURVwiLFxuICAgICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIjogXCIqXCIsXG4gICAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHNcIjogXCJPUFRJT05TICxQT1NUICxHRVQgLFBVVCAsREVMRVRFXCIsXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHJlc01lc3NhZ2U7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiBjcmVhdGVzIGEgY29tbWEgc2VwYXJhdGVkIGZvcm1hdCBvZiBrZXlzIGFuZCB2YWx1ZXMgdG8gdXNlIGluIHNldCBjbGF1c2Ugb2YgdXBkYXRlIHF1ZXJpZXNcbiAqIEBwYXJhbSB7Kn0ga2V5VmFsdWVPYmplY3RcbiAqIEByZXR1cm5zIHN0cmluZ1xuICogQGV4YW1wbGVcbiAqIGtleVZhbHVlT2JqZWN0OiB7XCJrZXkxXCI6IHZhbHVlMSwgXCJrZXkyXCI6IHZhbHVlMn1cbiAqIG91dHB1dDogXCJrZXkxPXZhbHVlMSwga2V5Mj12YWx1ZTJcIlxuICovXG5leHBvcnQgY29uc3QgZ2V0VXBkYXRlUXVlcnlTZXRDbGF1c2VGb3JtYXQgPSAoa2V5VmFsdWVPYmplY3Q6IGFueSk6IGFueSA9PiB7XG4gIGlmICgha2V5VmFsdWVPYmplY3QgfHwgdHlwZW9mIGtleVZhbHVlT2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IHR5cGUgaXMgcmVxdWlyZWRcIik7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoa2V5VmFsdWVPYmplY3QpXG4gICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9PScke3ZhbHVlfSdgKVxuICAgIC5qb2luKFwiLCBcIik7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbjogZnVuY3Rpb24gY3JlYXRlcyBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgb2YgcXVvdGVkIHZhbHVlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBwYXNzaW5nIGluc2lkZSBpbnNlcnQgcXVlcmllcy5cbiAqIEBwYXJhbSB7Kn0gZmllbGRBcnJheVxuICogQHJldHVybnMgc3RyaW5nXG4gKiBAZXhhbXBsZVxuICogZmllbGRBcnJheTogW1wicGVyc29uMVwiLCAyNiwgOTg3NjU0MzIxMF1cbiAqIG91dHB1dDogXCIncGVyc29uMScsICcyNicsICc5ODc2NTQzMjEwJ1wiXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JtYXRJbnNlcnRRdWVyeVZhbHVlcyA9IChmaWVsZEFycmF5OiBhbnkpOiBhbnkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZmllbGRBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBpcyByZXF1aXJlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBmaWVsZEFycmF5Lm1hcCgoZWxlbWVudCkgPT4gYCcke2VsZW1lbnR9J2ApLmpvaW4oXCIsXCIpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gZnVuY3Rpb24gY29tcGFyZXMgdHdvIGFycmF5cyBhbmQgcmV0dXJucyBrZXlzIGZyb20gZmlyc3QgYXJyYXkgd2hpY2ggYXJlIG5vdCBhdmFpbGFibGUgaW4gc2Vjb25kIGFycmF5XG4gKiBAcGFyYW0geyp9IHJlcXVpcmVkTGlzdCBhcnJheVxuICogQHBhcmFtIHsqfSBhdmFpbGFibGVMaXN0IGFycmF5XG4gKiBAcmV0dXJucyBhcnJheVxuICogQGV4YW1wbGVcbiAqIHJlcXVpcmVkTGlzdDogW1wib25lXCIsIFwidHdvXCJdXG4gKiBhdmFpbGFibGVMaXN0OiBbXCJ0d29cIiwgXCJ0aHJlZVwiXVxuICogcmV0dXJucyBbXCJvbmVcIl1cbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrTWlzc2luZ0tleXMgPSAoXG4gIHJlcXVpcmVkTGlzdCA9IFtdLFxuICBhdmFpbGFibGVMaXN0ID0gW11cbik6IGFueSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShyZXF1aXJlZExpc3QpIHx8ICFBcnJheS5pc0FycmF5KGF2YWlsYWJsZUxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgYW5kIEF2YWlsYWJsZSBMaXN0IG11c3QgYmUgYW4gYXJyYXlcIik7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZWRMaXN0LmZpbHRlcigoZWxlbWVudCkgPT4gYXZhaWxhYmxlTGlzdC5pbmRleE9mKGVsZW1lbnQpIDwgMCk7XG59O1xuXG4vLyAvKipcbi8vICAqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiBoYXNoZXMgbnVtYmVycyBhbmQgc3RyaW5ncy5cbi8vICAqIEBwYXJhbSB7Kn0gZGF0YVN0cmluZyBzdHJpbmcgfCBudW1iZXJcbi8vICAqIEBwYXJhbSB7Kn0gc2FsdFxuLy8gICogQHJldHVybnMgc3RyaW5nXG4vLyAgKi9cbi8vIGV4cG9ydCBjb25zdCBjcmVhdGVIYXNoID0gKGRhdGFTdHJpbmc6IHN0cmluZywgc2FsdDogc3RyaW5nKTogc3RyaW5nID0+IHtcbi8vICAgaWYgKHR5cGVvZiBkYXRhU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHR5cGUgaXMgcmVxdWlyZWRcIik7XG4vLyAgIH1cblxuLy8gICBjb25zdCBobWFjID0gY3JlYXRlSG1hYyhcInNoYTI1NlwiLCBzYWx0KTtcbi8vICAgcmV0dXJuIGhtYWMudXBkYXRlKGRhdGFTdHJpbmcpLmRpZ2VzdChcImhleFwiKTtcbi8vIH07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gbGltaXRcbiAqIEBwYXJhbSB7Kn0gcGFnZVxuICogQHJldHVybnMgeyBsaW1pdDogbnVtYmVyLCBvZmZzZXQ6IG51bWJlciB9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQYWdpbmF0aW9uUGFyYW1zID0gKFxuICBsaW1pdDogbnVtYmVyLFxuICBwYWdlOiBudW1iZXJcbik6IHtsaW1pdDogbnVtYmVyOyBvZmZzZXQ6IG51bWJlcn0gPT4ge1xuICBjb25zdCB7TElNSVQsIE1JTl9MSU1JVCwgTUFYX0xJTUlULCBERUZBVUxUX1BBR0V9ID0gUEFHSU5BVElPTjtcblxuICBpZiAodHlwZW9mIGxpbWl0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgbGltaXQgPSBMSU1JVDtcbiAgfSBlbHNlIHtcbiAgICBpZiAobGltaXQgPCBNSU5fTElNSVQpIHtcbiAgICAgIGxpbWl0ID0gTUlOX0xJTUlUO1xuICAgIH1cblxuICAgIGlmIChsaW1pdCA+IE1BWF9MSU1JVCkge1xuICAgICAgbGltaXQgPSBNQVhfTElNSVQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYWdlICE9PSBcIm51bWJlclwiIHx8IHBhZ2UgPCBERUZBVUxUX1BBR0UpIHtcbiAgICBwYWdlID0gREVGQVVMVF9QQUdFO1xuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gKHBhZ2UgLSAxKSAqIGxpbWl0O1xuXG4gIHJldHVybiB7bGltaXQsIG9mZnNldH07XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHBhc3NlZCBkYXRlIG9yIGN1cnJlbnQgZGF0ZSBpbnRvIHJlcXVpcmVkIHBhc3NlZCBmb3JtYXRcbiAqIEBwYXJhbSB7Kn0gZm9ybWF0XG4gKiBAcGFyYW0geyp9IGRhdGVcbiAqIEByZXR1cm5zIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgZ2V0Rm9ybWF0dGVkRGF0ZSA9IChmb3JtYXQ6IHN0cmluZywgZGF0ZTogRGF0ZSk6IHN0cmluZyA9PiB7XG4gIGlmIChkYXRlKSB7XG4gICAgcmV0dXJuIG1vbWVudChkYXRlKS5mb3JtYXQoZm9ybWF0KTtcbiAgfVxuXG4gIHJldHVybiBtb21lbnQoKS5mb3JtYXQoZm9ybWF0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRKc29uU3RyaW5nID0gKHN0cjogc3RyaW5nKTogYW55ID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoc3RyLnRvU3RyaW5nKCkgPT09IFwibnVsbFwiKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG5jb25zdCBpc09iamVjdCA9IGZ1bmN0aW9uIChvYmo6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKSAmJiAhaXNBcnJheShvYmopICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIjtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gZnVuY3Rpb24gKGFycmF5OiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyYXkpO1xufTtcblxuY29uc3QgdG9DYW1lbCA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFstX11bYS16XSkvZ2ksICgkMSkgPT4ge1xuICAgIHJldHVybiAkMS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoXCItXCIsIFwiXCIpLnJlcGxhY2UoXCJfXCIsIFwiXCIpO1xuICB9KTtcbn07XG5cbi8vIGV4cG9ydCBjb25zdCBrZXlzVG9DYW1lbCA9IGZ1bmN0aW9uIChvYmo6IGFueSk6IGFueSB7XG4vLyAgIGlmIChpc09iamVjdChvYmopKSB7XG4vLyAgICAgY29uc3QgbiA9IHt9O1xuXG4vLyAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbi8vICAgICAgIG5bdG9DYW1lbChrZXkpXSA9IGtleXNUb0NhbWVsKG9ialtrZXldKTtcbi8vICAgICB9KTtcblxuLy8gICAgIHJldHVybiBuO1xuLy8gICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkge1xuLy8gICAgIHJldHVybiBvYmoubWFwKChpbmRleCkgPT4ge1xuLy8gICAgICAgcmV0dXJuIGtleXNUb0NhbWVsKGluZGV4KTtcbi8vICAgICB9KTtcbi8vICAgfVxuXG4vLyAgIHJldHVybiBvYmo7XG4vLyB9O1xuIl19