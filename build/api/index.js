"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = exports.getJsonString = exports.getFormattedDate = exports.getPaginationParams = exports.checkMissingKeys = exports.formatInsertQueryValues = exports.getUpdateQuerySetClauseFormat = exports.getResponse = exports.DATE_TIME_FORMAT = exports.PAGINATION = exports.DATABASE_TRANSACTION_TYPES = exports.HTTP_STATUS_CODES = void 0;
// import {createHmac} from "crypto";
const moment_1 = __importDefault(require("moment"));
exports.HTTP_STATUS_CODES = {
    OK: 200,
    CREATED: 201,
    ACCEPTED: 202,
    NO_CONTENT: 204,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    REQUEST_TIMEOUT: 408,
    INTERNAL_SERVER_ERROR: 500,
    BAD_GATEWAY: 502,
    SERVICE_UNAVAILABLE: 503,
    GATEWAY_TIMEOUT: 504,
};
exports.DATABASE_TRANSACTION_TYPES = {
    BEGIN: "BEGIN",
    COMMIT: "COMMIT",
    ROLLBACK: "ROLLBACK",
};
exports.PAGINATION = {
    MIN_LIMIT: 1,
    MAX_LIMIT: 100,
    LIMIT: 20,
    DEFAULT_PAGE: 1,
};
exports.DATE_TIME_FORMAT = "YYYY-MM-DD HH:mm:ss.SSS";
const getResponse = (obj = { message: "Bad Request" }, statusCode = exports.HTTP_STATUS_CODES.BAD_REQUEST, contentType = "application/json") => {
    let resMessage = {
        body: JSON.stringify(obj),
        statusCode: statusCode,
        isBase64Encoded: false,
        headers: {
            "Content-Type": contentType,
            "Access-Control-Allow-Headers": "*",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "*",
        },
    };
    return resMessage;
};
exports.getResponse = getResponse;
/**
 * @description function creates a comma separated format of keys and values to use in set clause of update queries
 * @param {*} keyValueObject
 * @returns string
 * @example
 * keyValueObject: {"key1": value1, "key2": value2}
 * output: "key1=value1, key2=value2"
 */
const getUpdateQuerySetClauseFormat = (keyValueObject) => {
    if (!keyValueObject || typeof keyValueObject !== "object") {
        throw new Error("Object type is required");
    }
    return Object.entries(keyValueObject)
        .map(([key, value]) => `${key}='${value}'`)
        .join(", ");
};
exports.getUpdateQuerySetClauseFormat = getUpdateQuerySetClauseFormat;
/**
 * @description: function creates a comma-separated string of quoted values that can be used for passing inside insert queries.
 * @param {*} fieldArray
 * @returns string
 * @example
 * fieldArray: ["person1", 26, 9876543210]
 * output: "'person1', '26', '9876543210'"
 */
const formatInsertQueryValues = (fieldArray) => {
    if (!Array.isArray(fieldArray)) {
        throw new Error("Array is required");
    }
    return fieldArray.map((element) => `'${element}'`).join(",");
};
exports.formatInsertQueryValues = formatInsertQueryValues;
/**
 * @description function compares two arrays and returns keys from first array which are not available in second array
 * @param {*} requiredList array
 * @param {*} availableList array
 * @returns array
 * @example
 * requiredList: ["one", "two"]
 * availableList: ["two", "three"]
 * returns ["one"]
 */
const checkMissingKeys = (requiredList = [], availableList = []) => {
    if (!Array.isArray(requiredList) || !Array.isArray(availableList)) {
        throw new Error("Required and Available List must be an array");
    }
    return requiredList.filter((element) => availableList.indexOf(element) < 0);
};
exports.checkMissingKeys = checkMissingKeys;
// /**
//  * @description function hashes numbers and strings.
//  * @param {*} dataString string | number
//  * @param {*} salt
//  * @returns string
//  */
// export const createHash = (dataString: string, salt: string): string => {
//   if (typeof dataString !== "string") {
//     throw new Error("String type is required");
//   }
//   const hmac = createHmac("sha256", salt);
//   return hmac.update(dataString).digest("hex");
// };
/**
 *
 * @param {*} limit
 * @param {*} page
 * @returns { limit: number, offset: number }
 */
const getPaginationParams = (limit, page) => {
    const { LIMIT, MIN_LIMIT, MAX_LIMIT, DEFAULT_PAGE } = exports.PAGINATION;
    if (typeof limit !== "number") {
        limit = LIMIT;
    }
    else {
        if (limit < MIN_LIMIT) {
            limit = MIN_LIMIT;
        }
        if (limit > MAX_LIMIT) {
            limit = MAX_LIMIT;
        }
    }
    if (typeof page !== "number" || page < DEFAULT_PAGE) {
        page = DEFAULT_PAGE;
    }
    const offset = (page - 1) * limit;
    return { limit, offset };
};
exports.getPaginationParams = getPaginationParams;
/**
 * @description returns passed date or current date into required passed format
 * @param {*} format
 * @param {*} date
 * @returns string
 */
const getFormattedDate = (format, date) => {
    if (date) {
        return (0, moment_1.default)(date).format(format);
    }
    return (0, moment_1.default)().format(format);
};
exports.getFormattedDate = getFormattedDate;
const getJsonString = (str) => {
    try {
        if (str.toString() === "null")
            throw new Error();
        return JSON.parse(str);
    }
    catch (e) {
        return {};
    }
};
exports.getJsonString = getJsonString;
const isObject = function (obj) {
    return obj === Object(obj) && !(0, exports.isArray)(obj) && typeof obj !== "function";
};
const isArray = function (array) {
    return Array.isArray(array);
};
exports.isArray = isArray;
const toCamel = (str) => {
    return str.replace(/([-_][a-z])/gi, ($1) => {
        return $1.toUpperCase().replace("-", "").replace("_", "");
    });
};
// export const keysToCamel = function (obj: any): any {
//   if (isObject(obj)) {
//     const n = {};
//     Object.keys(obj).forEach((key) => {
//       n[toCamel(key)] = keysToCamel(obj[key]);
//     });
//     return n;
//   } else if (isArray(obj)) {
//     return obj.map((index) => {
//       return keysToCamel(index);
//     });
//   }
//   return obj;
// };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXBpL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHFDQUFxQztBQUNyQyxvREFBNEI7QUFFZixRQUFBLGlCQUFpQixHQUFHO0lBQy9CLEVBQUUsRUFBRSxHQUFHO0lBQ1AsT0FBTyxFQUFFLEdBQUc7SUFDWixRQUFRLEVBQUUsR0FBRztJQUNiLFVBQVUsRUFBRSxHQUFHO0lBQ2YsV0FBVyxFQUFFLEdBQUc7SUFDaEIsWUFBWSxFQUFFLEdBQUc7SUFDakIsU0FBUyxFQUFFLEdBQUc7SUFDZCxTQUFTLEVBQUUsR0FBRztJQUNkLGVBQWUsRUFBRSxHQUFHO0lBQ3BCLHFCQUFxQixFQUFFLEdBQUc7SUFDMUIsV0FBVyxFQUFFLEdBQUc7SUFDaEIsbUJBQW1CLEVBQUUsR0FBRztJQUN4QixlQUFlLEVBQUUsR0FBRztDQUNyQixDQUFDO0FBRVcsUUFBQSwwQkFBMEIsR0FBRztJQUN4QyxLQUFLLEVBQUUsT0FBTztJQUNkLE1BQU0sRUFBRSxRQUFRO0lBQ2hCLFFBQVEsRUFBRSxVQUFVO0NBQ3JCLENBQUM7QUFFVyxRQUFBLFVBQVUsR0FBRztJQUN4QixTQUFTLEVBQUUsQ0FBQztJQUNaLFNBQVMsRUFBRSxHQUFHO0lBQ2QsS0FBSyxFQUFFLEVBQUU7SUFDVCxZQUFZLEVBQUUsQ0FBQztDQUNoQixDQUFDO0FBRVcsUUFBQSxnQkFBZ0IsR0FBRyx5QkFBeUIsQ0FBQztBQUVuRCxNQUFNLFdBQVcsR0FBRyxDQUN6QixNQUFXLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBQyxFQUNuQyxhQUFxQix5QkFBaUIsQ0FBQyxXQUFXLEVBQ2xELGNBQXNCLGtCQUFrQixFQU14QyxFQUFFO0lBQ0YsSUFBSSxVQUFVLEdBQUc7UUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7UUFDekIsVUFBVSxFQUFFLFVBQVU7UUFDdEIsZUFBZSxFQUFF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LFVBQVUsQ0FBQztBQUMzRSxDQUFDLENBQUM7QUFFSyxNQUFNLE9BQU8sR0FBRyxVQUFVLEtBQVU7SUFDekMsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQztBQUZXLFFBQUEsT0FBTyxXQUVsQjtBQUVGLE1BQU0sT0FBTyxHQUFHLENBQUMsR0FBVyxFQUFVLEVBQUU7SUFDdEMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFO1FBQ3pDLE9BQU8sRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM1RCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQztBQUVGLHdEQUF3RDtBQUN4RCx5QkFBeUI7QUFDekIsb0JBQW9CO0FBRXBCLDBDQUEwQztBQUMxQyxpREFBaUQ7QUFDakQsVUFBVTtBQUVWLGdCQUFnQjtBQUNoQiwrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQyxVQUFVO0FBQ1YsTUFBTTtBQUVOLGdCQUFnQjtBQUNoQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHtjcmVhdGVIbWFjfSBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgbW9tZW50IGZyb20gXCJtb21lbnRcIjtcblxuZXhwb3J0IGNvbnN0IEhUVFBfU1RBVFVTX0NPREVTID0ge1xuICBPSzogMjAwLFxuICBDUkVBVEVEOiAyMDEsXG4gIEFDQ0VQVEVEOiAyMDIsXG4gIE5PX0NPTlRFTlQ6IDIwNCxcbiAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gIEZPUkJJRERFTjogNDAzLFxuICBOT1RfRk9VTkQ6IDQwNCxcbiAgUkVRVUVTVF9USU1FT1VUOiA0MDgsXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICBCQURfR0FURVdBWTogNTAyLFxuICBTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG4gIEdBVEVXQVlfVElNRU9VVDogNTA0LFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEFCQVNFX1RSQU5TQUNUSU9OX1RZUEVTID0ge1xuICBCRUdJTjogXCJCRUdJTlwiLFxuICBDT01NSVQ6IFwiQ09NTUlUXCIsXG4gIFJPTExCQUNLOiBcIlJPTExCQUNLXCIsXG59O1xuXG5leHBvcnQgY29uc3QgUEFHSU5BVElPTiA9IHtcbiAgTUlOX0xJTUlUOiAxLFxuICBNQVhfTElNSVQ6IDEwMCxcbiAgTElNSVQ6IDIwLFxuICBERUZBVUxUX1BBR0U6IDEsXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9USU1FX0ZPUk1BVCA9IFwiWVlZWS1NTS1ERCBISDptbTpzcy5TU1NcIjtcblxuZXhwb3J0IGNvbnN0IGdldFJlc3BvbnNlID0gKFxuICBvYmo6IGFueSA9IHttZXNzYWdlOiBcIkJhZCBSZXF1ZXN0XCJ9LFxuICBzdGF0dXNDb2RlOiBudW1iZXIgPSBIVFRQX1NUQVRVU19DT0RFUy5CQURfUkVRVUVTVCxcbiAgY29udGVudFR5cGU6IHN0cmluZyA9IFwiYXBwbGljYXRpb24vanNvblwiXG4pOiB7XG4gIGJvZHk6IHN0cmluZztcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBpc0Jhc2U2NEVuY29kZWQ/OiBib29sZWFuO1xuICBoZWFkZXJzOiBhbnk7XG59ID0+IHtcbiAgbGV0IHJlc01lc3NhZ2UgPSB7XG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkob2JqKSxcbiAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgIGlzQmFzZTY0RW5jb2RlZDogZmFsc2UsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGUsXG4gICAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIjogXCIqXCIsXG4gICAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiOiBcIipcIixcbiAgICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kc1wiOiBcIipcIixcbiAgICB9LFxuICB9O1xuICByZXR1cm4gcmVzTWVzc2FnZTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIGZ1bmN0aW9uIGNyZWF0ZXMgYSBjb21tYSBzZXBhcmF0ZWQgZm9ybWF0IG9mIGtleXMgYW5kIHZhbHVlcyB0byB1c2UgaW4gc2V0IGNsYXVzZSBvZiB1cGRhdGUgcXVlcmllc1xuICogQHBhcmFtIHsqfSBrZXlWYWx1ZU9iamVjdFxuICogQHJldHVybnMgc3RyaW5nXG4gKiBAZXhhbXBsZVxuICoga2V5VmFsdWVPYmplY3Q6IHtcImtleTFcIjogdmFsdWUxLCBcImtleTJcIjogdmFsdWUyfVxuICogb3V0cHV0OiBcImtleTE9dmFsdWUxLCBrZXkyPXZhbHVlMlwiXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVcGRhdGVRdWVyeVNldENsYXVzZUZvcm1hdCA9IChrZXlWYWx1ZU9iamVjdDogYW55KTogYW55ID0+IHtcbiAgaWYgKCFrZXlWYWx1ZU9iamVjdCB8fCB0eXBlb2Yga2V5VmFsdWVPYmplY3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3QgdHlwZSBpcyByZXF1aXJlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhrZXlWYWx1ZU9iamVjdClcbiAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX09JyR7dmFsdWV9J2ApXG4gICAgLmpvaW4oXCIsIFwiKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uOiBmdW5jdGlvbiBjcmVhdGVzIGEgY29tbWEtc2VwYXJhdGVkIHN0cmluZyBvZiBxdW90ZWQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHBhc3NpbmcgaW5zaWRlIGluc2VydCBxdWVyaWVzLlxuICogQHBhcmFtIHsqfSBmaWVsZEFycmF5XG4gKiBAcmV0dXJucyBzdHJpbmdcbiAqIEBleGFtcGxlXG4gKiBmaWVsZEFycmF5OiBbXCJwZXJzb24xXCIsIDI2LCA5ODc2NTQzMjEwXVxuICogb3V0cHV0OiBcIidwZXJzb24xJywgJzI2JywgJzk4NzY1NDMyMTAnXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcm1hdEluc2VydFF1ZXJ5VmFsdWVzID0gKGZpZWxkQXJyYXk6IGFueSk6IGFueSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmaWVsZEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGlzIHJlcXVpcmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkQXJyYXkubWFwKChlbGVtZW50KSA9PiBgJyR7ZWxlbWVudH0nYCkuam9pbihcIixcIik7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiBjb21wYXJlcyB0d28gYXJyYXlzIGFuZCByZXR1cm5zIGtleXMgZnJvbSBmaXJzdCBhcnJheSB3aGljaCBhcmUgbm90IGF2YWlsYWJsZSBpbiBzZWNvbmQgYXJyYXlcbiAqIEBwYXJhbSB7Kn0gcmVxdWlyZWRMaXN0IGFycmF5XG4gKiBAcGFyYW0geyp9IGF2YWlsYWJsZUxpc3QgYXJyYXlcbiAqIEByZXR1cm5zIGFycmF5XG4gKiBAZXhhbXBsZVxuICogcmVxdWlyZWRMaXN0OiBbXCJvbmVcIiwgXCJ0d29cIl1cbiAqIGF2YWlsYWJsZUxpc3Q6IFtcInR3b1wiLCBcInRocmVlXCJdXG4gKiByZXR1cm5zIFtcIm9uZVwiXVxuICovXG5leHBvcnQgY29uc3QgY2hlY2tNaXNzaW5nS2V5cyA9IChcbiAgcmVxdWlyZWRMaXN0ID0gW10sXG4gIGF2YWlsYWJsZUxpc3QgPSBbXVxuKTogYW55ID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlcXVpcmVkTGlzdCkgfHwgIUFycmF5LmlzQXJyYXkoYXZhaWxhYmxlTGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBhbmQgQXZhaWxhYmxlIExpc3QgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgfVxuXG4gIHJldHVybiByZXF1aXJlZExpc3QuZmlsdGVyKChlbGVtZW50KSA9PiBhdmFpbGFibGVMaXN0LmluZGV4T2YoZWxlbWVudCkgPCAwKTtcbn07XG5cbi8vIC8qKlxuLy8gICogQGRlc2NyaXB0aW9uIGZ1bmN0aW9uIGhhc2hlcyBudW1iZXJzIGFuZCBzdHJpbmdzLlxuLy8gICogQHBhcmFtIHsqfSBkYXRhU3RyaW5nIHN0cmluZyB8IG51bWJlclxuLy8gICogQHBhcmFtIHsqfSBzYWx0XG4vLyAgKiBAcmV0dXJucyBzdHJpbmdcbi8vICAqL1xuLy8gZXhwb3J0IGNvbnN0IGNyZWF0ZUhhc2ggPSAoZGF0YVN0cmluZzogc3RyaW5nLCBzYWx0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuLy8gICBpZiAodHlwZW9mIGRhdGFTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbi8vICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdHlwZSBpcyByZXF1aXJlZFwiKTtcbi8vICAgfVxuXG4vLyAgIGNvbnN0IGhtYWMgPSBjcmVhdGVIbWFjKFwic2hhMjU2XCIsIHNhbHQpO1xuLy8gICByZXR1cm4gaG1hYy51cGRhdGUoZGF0YVN0cmluZykuZGlnZXN0KFwiaGV4XCIpO1xuLy8gfTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBsaW1pdFxuICogQHBhcmFtIHsqfSBwYWdlXG4gKiBAcmV0dXJucyB7IGxpbWl0OiBudW1iZXIsIG9mZnNldDogbnVtYmVyIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFBhZ2luYXRpb25QYXJhbXMgPSAoXG4gIGxpbWl0OiBudW1iZXIsXG4gIHBhZ2U6IG51bWJlclxuKToge2xpbWl0OiBudW1iZXI7IG9mZnNldDogbnVtYmVyfSA9PiB7XG4gIGNvbnN0IHtMSU1JVCwgTUlOX0xJTUlULCBNQVhfTElNSVQsIERFRkFVTFRfUEFHRX0gPSBQQUdJTkFUSU9OO1xuXG4gIGlmICh0eXBlb2YgbGltaXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICBsaW1pdCA9IExJTUlUO1xuICB9IGVsc2Uge1xuICAgIGlmIChsaW1pdCA8IE1JTl9MSU1JVCkge1xuICAgICAgbGltaXQgPSBNSU5fTElNSVQ7XG4gICAgfVxuXG4gICAgaWYgKGxpbWl0ID4gTUFYX0xJTUlUKSB7XG4gICAgICBsaW1pdCA9IE1BWF9MSU1JVDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBhZ2UgIT09IFwibnVtYmVyXCIgfHwgcGFnZSA8IERFRkFVTFRfUEFHRSkge1xuICAgIHBhZ2UgPSBERUZBVUxUX1BBR0U7XG4gIH1cblxuICBjb25zdCBvZmZzZXQgPSAocGFnZSAtIDEpICogbGltaXQ7XG5cbiAgcmV0dXJuIHtsaW1pdCwgb2Zmc2V0fTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIHJldHVybnMgcGFzc2VkIGRhdGUgb3IgY3VycmVudCBkYXRlIGludG8gcmVxdWlyZWQgcGFzc2VkIGZvcm1hdFxuICogQHBhcmFtIHsqfSBmb3JtYXRcbiAqIEBwYXJhbSB7Kn0gZGF0ZVxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGb3JtYXR0ZWREYXRlID0gKGZvcm1hdDogc3RyaW5nLCBkYXRlOiBEYXRlKTogc3RyaW5nID0+IHtcbiAgaWYgKGRhdGUpIHtcbiAgICByZXR1cm4gbW9tZW50KGRhdGUpLmZvcm1hdChmb3JtYXQpO1xuICB9XG5cbiAgcmV0dXJuIG1vbWVudCgpLmZvcm1hdChmb3JtYXQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEpzb25TdHJpbmcgPSAoc3RyOiBzdHJpbmcpOiBhbnkgPT4ge1xuICB0cnkge1xuICAgIGlmIChzdHIudG9TdHJpbmcoKSA9PT0gXCJudWxsXCIpIHRocm93IG5ldyBFcnJvcigpO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbmNvbnN0IGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iajogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiBvYmogPT09IE9iamVjdChvYmopICYmICFpc0FycmF5KG9iaikgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXk6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnJheSk7XG59O1xuXG5jb25zdCB0b0NhbWVsID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy1fXVthLXpdKS9naSwgKCQxKSA9PiB7XG4gICAgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCkucmVwbGFjZShcIi1cIiwgXCJcIikucmVwbGFjZShcIl9cIiwgXCJcIik7XG4gIH0pO1xufTtcblxuLy8gZXhwb3J0IGNvbnN0IGtleXNUb0NhbWVsID0gZnVuY3Rpb24gKG9iajogYW55KTogYW55IHtcbi8vICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbi8vICAgICBjb25zdCBuID0ge307XG5cbi8vICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuLy8gICAgICAgblt0b0NhbWVsKGtleSldID0ga2V5c1RvQ2FtZWwob2JqW2tleV0pO1xuLy8gICAgIH0pO1xuXG4vLyAgICAgcmV0dXJuIG47XG4vLyAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7XG4vLyAgICAgcmV0dXJuIG9iai5tYXAoKGluZGV4KSA9PiB7XG4vLyAgICAgICByZXR1cm4ga2V5c1RvQ2FtZWwoaW5kZXgpO1xuLy8gICAgIH0pO1xuLy8gICB9XG5cbi8vICAgcmV0dXJuIG9iajtcbi8vIH07XG4iXX0=