"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = exports.getJsonString = exports.getFormattedDate = exports.getPaginationParams = exports.checkMissingKeys = exports.formatInsertQueryValues = exports.getUpdateQuerySetClauseFormat = exports.getResponse = exports.DATE_TIME_FORMAT = exports.PAGINATION = exports.DATABASE_TRANSACTION_TYPES = exports.HTTP_STATUS_CODES = void 0;
// import {createHmac} from "crypto";
const moment_1 = __importDefault(require("moment"));
exports.HTTP_STATUS_CODES = {
    OK: 200,
    CREATED: 201,
    ACCEPTED: 202,
    NO_CONTENT: 204,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    REQUEST_TIMEOUT: 408,
    INTERNAL_SERVER_ERROR: 500,
    BAD_GATEWAY: 502,
    SERVICE_UNAVAILABLE: 503,
    GATEWAY_TIMEOUT: 504,
};
exports.DATABASE_TRANSACTION_TYPES = {
    BEGIN: "BEGIN",
    COMMIT: "COMMIT",
    ROLLBACK: "ROLLBACK",
};
exports.PAGINATION = {
    MIN_LIMIT: 1,
    MAX_LIMIT: 100,
    LIMIT: 20,
    DEFAULT_PAGE: 1,
};
exports.DATE_TIME_FORMAT = "YYYY-MM-DD HH:mm:ss.SSS";
const getResponse = (obj = { message: "Bad Request" }, statusCode = exports.HTTP_STATUS_CODES.BAD_REQUEST, contentType = "application/json") => {
    let resMessage = {
        body: JSON.stringify(obj),
        statusCode: statusCode,
        isBase64Encoded: false,
        headers: {
            contentType,
            "Access-Control-Allow-Headers": "Content-Type",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "OPTIONS,POST,GET,PUT,DELETE",
        },
    };
    return resMessage;
};
exports.getResponse = getResponse;
/**
 * @description function creates a comma separated format of keys and values to use in set clause of update queries
 * @param {*} keyValueObject
 * @returns string
 * @example
 * keyValueObject: {"key1": value1, "key2": value2}
 * output: "key1=value1, key2=value2"
 */
const getUpdateQuerySetClauseFormat = (keyValueObject) => {
    if (!keyValueObject || typeof keyValueObject !== "object") {
        throw new Error("Object type is required");
    }
    return Object.entries(keyValueObject)
        .map(([key, value]) => `${key}='${value}'`)
        .join(", ");
};
exports.getUpdateQuerySetClauseFormat = getUpdateQuerySetClauseFormat;
/**
 * @description: function creates a comma-separated string of quoted values that can be used for passing inside insert queries.
 * @param {*} fieldArray
 * @returns string
 * @example
 * fieldArray: ["person1", 26, 9876543210]
 * output: "'person1', '26', '9876543210'"
 */
const formatInsertQueryValues = (fieldArray) => {
    if (!Array.isArray(fieldArray)) {
        throw new Error("Array is required");
    }
    return fieldArray.map((element) => `'${element}'`).join(",");
};
exports.formatInsertQueryValues = formatInsertQueryValues;
/**
 * @description function compares two arrays and returns keys from first array which are not available in second array
 * @param {*} requiredList array
 * @param {*} availableList array
 * @returns array
 * @example
 * requiredList: ["one", "two"]
 * availableList: ["two", "three"]
 * returns ["one"]
 */
const checkMissingKeys = (requiredList = [], availableList = []) => {
    if (!Array.isArray(requiredList) || !Array.isArray(availableList)) {
        throw new Error("Required and Available List must be an array");
    }
    return requiredList.filter((element) => availableList.indexOf(element) < 0);
};
exports.checkMissingKeys = checkMissingKeys;
// /**
//  * @description function hashes numbers and strings.
//  * @param {*} dataString string | number
//  * @param {*} salt
//  * @returns string
//  */
// export const createHash = (dataString: string, salt: string): string => {
//   if (typeof dataString !== "string") {
//     throw new Error("String type is required");
//   }
//   const hmac = createHmac("sha256", salt);
//   return hmac.update(dataString).digest("hex");
// };
/**
 *
 * @param {*} limit
 * @param {*} page
 * @returns { limit: number, offset: number }
 */
const getPaginationParams = (limit, page) => {
    const { LIMIT, MIN_LIMIT, MAX_LIMIT, DEFAULT_PAGE } = exports.PAGINATION;
    if (typeof limit !== "number") {
        limit = LIMIT;
    }
    else {
        if (limit < MIN_LIMIT) {
            limit = MIN_LIMIT;
        }
        if (limit > MAX_LIMIT) {
            limit = MAX_LIMIT;
        }
    }
    if (typeof page !== "number" || page < DEFAULT_PAGE) {
        page = DEFAULT_PAGE;
    }
    const offset = (page - 1) * limit;
    return { limit, offset };
};
exports.getPaginationParams = getPaginationParams;
/**
 * @description returns passed date or current date into required passed format
 * @param {*} format
 * @param {*} date
 * @returns string
 */
const getFormattedDate = (format, date) => {
    if (date) {
        return (0, moment_1.default)(date).format(format);
    }
    return (0, moment_1.default)().format(format);
};
exports.getFormattedDate = getFormattedDate;
const getJsonString = (str) => {
    try {
        if (str.toString() === "null")
            throw new Error();
        return JSON.parse(str);
    }
    catch (e) {
        return {};
    }
};
exports.getJsonString = getJsonString;
const isObject = function (obj) {
    return obj === Object(obj) && !(0, exports.isArray)(obj) && typeof obj !== "function";
};
const isArray = function (array) {
    return Array.isArray(array);
};
exports.isArray = isArray;
const toCamel = (str) => {
    return str.replace(/([-_][a-z])/gi, ($1) => {
        return $1.toUpperCase().replace("-", "").replace("_", "");
    });
};
// export const keysToCamel = function (obj: any): any {
//   if (isObject(obj)) {
//     const n = {};
//     Object.keys(obj).forEach((key) => {
//       n[toCamel(key)] = keysToCamel(obj[key]);
//     });
//     return n;
//   } else if (isArray(obj)) {
//     return obj.map((index) => {
//       return keysToCamel(index);
//     });
//   }
//   return obj;
// };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXBpL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHFDQUFxQztBQUNyQyxvREFBNEI7QUFFZixRQUFBLGlCQUFpQixHQUFHO0lBQy9CLEVBQUUsRUFBRSxHQUFHO0lBQ1AsT0FBTyxFQUFFLEdBQUc7SUFDWixRQUFRLEVBQUUsR0FBRztJQUNiLFVBQVUsRUFBRSxHQUFHO0lBQ2YsV0FBVyxFQUFFLEdBQUc7SUFDaEIsWUFBWSxFQUFFLEdBQUc7SUFDakIsU0FBUyxFQUFFLEdBQUc7SUFDZCxTQUFTLEVBQUUsR0FBRztJQUNkLGVBQWUsRUFBRSxHQUFHO0lBQ3BCLHFCQUFxQixFQUFFLEdBQUc7SUFDMUIsV0FBVyxFQUFFLEdBQUc7SUFDaEIsbUJBQW1CLEVBQUUsR0FBRztJQUN4QixlQUFlLEVBQUUsR0FBRztDQUNyQixDQUFDO0FBRVcsUUFBQSwwQkFBMEIsR0FBRztJQUN4QyxLQUFLLEVBQUUsT0FBTztJQUNkLE1BQU0sRUFBRSxRQUFRO0lBQ2hCLFFBQVEsRUFBRSxVQUFVO0NBQ3JCLENBQUM7QUFFVyxRQUFBLFVBQVUsR0FBRztJQUN4QixTQUFTLEVBQUUsQ0FBQztJQUNaLFNBQVMsRUFBRSxHQUFHO0lBQ2QsS0FBSyxFQUFFLEVBQUU7SUFDVCxZQUFZLEVBQUUsQ0FBQztDQUNoQixDQUFDO0FBRVcsUUFBQSxnQkFBZ0IsR0FBRyx5QkFBeUIsQ0FBQztBQUVuRCxNQUFNLFdBQVcsR0FBRyxDQUN6QixNQUFXLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBQyxFQUNuQyxhQUFxQix5QkFBaUIsQ0FBQyxXQUFXLEVBQ2xELGNBQXNCLGtCQUFrQixFQU14QyxFQUFFO0lBQ0YsSUFBSSxVQUFVLEdBQUc7UUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7UUFDekIsVUFBVSxFQUFFLFVBQVU7UUFDdEIsZUFBZSxFQUFF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QztBQUMzRSxDQUFDLENBQUM7QUFFSyxNQUFNLE9BQU8sR0FBRyxVQUFVLEtBQVU7SUFDekMsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQztBQUZXLFFBQUEsT0FBTyxXQUVsQjtBQUVGLE1BQU0sT0FBTyxHQUFHLENBQUMsR0FBVyxFQUFVLEVBQUU7SUFDdEMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFO1FBQ3pDLE9BQU8sRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM1RCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQztBQUVGLHdEQUF3RDtBQUN4RCx5QkFBeUI7QUFDekIsb0JBQW9CO0FBRXBCLDBDQUEwQztBQUMxQyxpREFBaUQ7QUFDakQsVUFBVTtBQUVWLGdCQUFnQjtBQUNoQiwrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQyxVQUFVO0FBQ1YsTUFBTTtBQUVOLGdCQUFnQjtBQUNoQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHtjcmVhdGVIbWFjfSBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgbW9tZW50IGZyb20gXCJtb21lbnRcIjtcblxuZXhwb3J0IGNvbnN0IEhUVFBfU1RBVFVTX0NPREVTID0ge1xuICBPSzogMjAwLFxuICBDUkVBVEVEOiAyMDEsXG4gIEFDQ0VQVEVEOiAyMDIsXG4gIE5PX0NPTlRFTlQ6IDIwNCxcbiAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gIEZPUkJJRERFTjogNDAzLFxuICBOT1RfRk9VTkQ6IDQwNCxcbiAgUkVRVUVTVF9USU1FT1VUOiA0MDgsXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICBCQURfR0FURVdBWTogNTAyLFxuICBTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG4gIEdBVEVXQVlfVElNRU9VVDogNTA0LFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEFCQVNFX1RSQU5TQUNUSU9OX1RZUEVTID0ge1xuICBCRUdJTjogXCJCRUdJTlwiLFxuICBDT01NSVQ6IFwiQ09NTUlUXCIsXG4gIFJPTExCQUNLOiBcIlJPTExCQUNLXCIsXG59O1xuXG5leHBvcnQgY29uc3QgUEFHSU5BVElPTiA9IHtcbiAgTUlOX0xJTUlUOiAxLFxuICBNQVhfTElNSVQ6IDEwMCxcbiAgTElNSVQ6IDIwLFxuICBERUZBVUxUX1BBR0U6IDEsXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9USU1FX0ZPUk1BVCA9IFwiWVlZWS1NTS1ERCBISDptbTpzcy5TU1NcIjtcblxuZXhwb3J0IGNvbnN0IGdldFJlc3BvbnNlID0gKFxuICBvYmo6IGFueSA9IHttZXNzYWdlOiBcIkJhZCBSZXF1ZXN0XCJ9LFxuICBzdGF0dXNDb2RlOiBudW1iZXIgPSBIVFRQX1NUQVRVU19DT0RFUy5CQURfUkVRVUVTVCxcbiAgY29udGVudFR5cGU6IHN0cmluZyA9IFwiYXBwbGljYXRpb24vanNvblwiXG4pOiB7XG4gIGJvZHk6IHN0cmluZztcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBpc0Jhc2U2NEVuY29kZWQ/OiBib29sZWFuO1xuICBoZWFkZXJzOiBhbnk7XG59ID0+IHtcbiAgbGV0IHJlc01lc3NhZ2UgPSB7XG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkob2JqKSxcbiAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgIGlzQmFzZTY0RW5jb2RlZDogZmFsc2UsXG4gICAgaGVhZGVyczoge1xuICAgICAgY29udGVudFR5cGUsXG4gICAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIjogXCJDb250ZW50LVR5cGVcIixcbiAgICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCI6IFwiKlwiLFxuICAgICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCI6IFwiT1BUSU9OUyxQT1NULEdFVCxQVVQsREVMRVRFXCIsXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHJlc01lc3NhZ2U7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiBjcmVhdGVzIGEgY29tbWEgc2VwYXJhdGVkIGZvcm1hdCBvZiBrZXlzIGFuZCB2YWx1ZXMgdG8gdXNlIGluIHNldCBjbGF1c2Ugb2YgdXBkYXRlIHF1ZXJpZXNcbiAqIEBwYXJhbSB7Kn0ga2V5VmFsdWVPYmplY3RcbiAqIEByZXR1cm5zIHN0cmluZ1xuICogQGV4YW1wbGVcbiAqIGtleVZhbHVlT2JqZWN0OiB7XCJrZXkxXCI6IHZhbHVlMSwgXCJrZXkyXCI6IHZhbHVlMn1cbiAqIG91dHB1dDogXCJrZXkxPXZhbHVlMSwga2V5Mj12YWx1ZTJcIlxuICovXG5leHBvcnQgY29uc3QgZ2V0VXBkYXRlUXVlcnlTZXRDbGF1c2VGb3JtYXQgPSAoa2V5VmFsdWVPYmplY3Q6IGFueSk6IGFueSA9PiB7XG4gIGlmICgha2V5VmFsdWVPYmplY3QgfHwgdHlwZW9mIGtleVZhbHVlT2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IHR5cGUgaXMgcmVxdWlyZWRcIik7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoa2V5VmFsdWVPYmplY3QpXG4gICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9PScke3ZhbHVlfSdgKVxuICAgIC5qb2luKFwiLCBcIik7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbjogZnVuY3Rpb24gY3JlYXRlcyBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgb2YgcXVvdGVkIHZhbHVlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBwYXNzaW5nIGluc2lkZSBpbnNlcnQgcXVlcmllcy5cbiAqIEBwYXJhbSB7Kn0gZmllbGRBcnJheVxuICogQHJldHVybnMgc3RyaW5nXG4gKiBAZXhhbXBsZVxuICogZmllbGRBcnJheTogW1wicGVyc29uMVwiLCAyNiwgOTg3NjU0MzIxMF1cbiAqIG91dHB1dDogXCIncGVyc29uMScsICcyNicsICc5ODc2NTQzMjEwJ1wiXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JtYXRJbnNlcnRRdWVyeVZhbHVlcyA9IChmaWVsZEFycmF5OiBhbnkpOiBhbnkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZmllbGRBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBpcyByZXF1aXJlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBmaWVsZEFycmF5Lm1hcCgoZWxlbWVudCkgPT4gYCcke2VsZW1lbnR9J2ApLmpvaW4oXCIsXCIpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gZnVuY3Rpb24gY29tcGFyZXMgdHdvIGFycmF5cyBhbmQgcmV0dXJucyBrZXlzIGZyb20gZmlyc3QgYXJyYXkgd2hpY2ggYXJlIG5vdCBhdmFpbGFibGUgaW4gc2Vjb25kIGFycmF5XG4gKiBAcGFyYW0geyp9IHJlcXVpcmVkTGlzdCBhcnJheVxuICogQHBhcmFtIHsqfSBhdmFpbGFibGVMaXN0IGFycmF5XG4gKiBAcmV0dXJucyBhcnJheVxuICogQGV4YW1wbGVcbiAqIHJlcXVpcmVkTGlzdDogW1wib25lXCIsIFwidHdvXCJdXG4gKiBhdmFpbGFibGVMaXN0OiBbXCJ0d29cIiwgXCJ0aHJlZVwiXVxuICogcmV0dXJucyBbXCJvbmVcIl1cbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrTWlzc2luZ0tleXMgPSAoXG4gIHJlcXVpcmVkTGlzdCA9IFtdLFxuICBhdmFpbGFibGVMaXN0ID0gW11cbik6IGFueSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShyZXF1aXJlZExpc3QpIHx8ICFBcnJheS5pc0FycmF5KGF2YWlsYWJsZUxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgYW5kIEF2YWlsYWJsZSBMaXN0IG11c3QgYmUgYW4gYXJyYXlcIik7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZWRMaXN0LmZpbHRlcigoZWxlbWVudCkgPT4gYXZhaWxhYmxlTGlzdC5pbmRleE9mKGVsZW1lbnQpIDwgMCk7XG59O1xuXG4vLyAvKipcbi8vICAqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiBoYXNoZXMgbnVtYmVycyBhbmQgc3RyaW5ncy5cbi8vICAqIEBwYXJhbSB7Kn0gZGF0YVN0cmluZyBzdHJpbmcgfCBudW1iZXJcbi8vICAqIEBwYXJhbSB7Kn0gc2FsdFxuLy8gICogQHJldHVybnMgc3RyaW5nXG4vLyAgKi9cbi8vIGV4cG9ydCBjb25zdCBjcmVhdGVIYXNoID0gKGRhdGFTdHJpbmc6IHN0cmluZywgc2FsdDogc3RyaW5nKTogc3RyaW5nID0+IHtcbi8vICAgaWYgKHR5cGVvZiBkYXRhU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHR5cGUgaXMgcmVxdWlyZWRcIik7XG4vLyAgIH1cblxuLy8gICBjb25zdCBobWFjID0gY3JlYXRlSG1hYyhcInNoYTI1NlwiLCBzYWx0KTtcbi8vICAgcmV0dXJuIGhtYWMudXBkYXRlKGRhdGFTdHJpbmcpLmRpZ2VzdChcImhleFwiKTtcbi8vIH07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gbGltaXRcbiAqIEBwYXJhbSB7Kn0gcGFnZVxuICogQHJldHVybnMgeyBsaW1pdDogbnVtYmVyLCBvZmZzZXQ6IG51bWJlciB9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQYWdpbmF0aW9uUGFyYW1zID0gKFxuICBsaW1pdDogbnVtYmVyLFxuICBwYWdlOiBudW1iZXJcbik6IHtsaW1pdDogbnVtYmVyOyBvZmZzZXQ6IG51bWJlcn0gPT4ge1xuICBjb25zdCB7TElNSVQsIE1JTl9MSU1JVCwgTUFYX0xJTUlULCBERUZBVUxUX1BBR0V9ID0gUEFHSU5BVElPTjtcblxuICBpZiAodHlwZW9mIGxpbWl0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgbGltaXQgPSBMSU1JVDtcbiAgfSBlbHNlIHtcbiAgICBpZiAobGltaXQgPCBNSU5fTElNSVQpIHtcbiAgICAgIGxpbWl0ID0gTUlOX0xJTUlUO1xuICAgIH1cblxuICAgIGlmIChsaW1pdCA+IE1BWF9MSU1JVCkge1xuICAgICAgbGltaXQgPSBNQVhfTElNSVQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYWdlICE9PSBcIm51bWJlclwiIHx8IHBhZ2UgPCBERUZBVUxUX1BBR0UpIHtcbiAgICBwYWdlID0gREVGQVVMVF9QQUdFO1xuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gKHBhZ2UgLSAxKSAqIGxpbWl0O1xuXG4gIHJldHVybiB7bGltaXQsIG9mZnNldH07XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHBhc3NlZCBkYXRlIG9yIGN1cnJlbnQgZGF0ZSBpbnRvIHJlcXVpcmVkIHBhc3NlZCBmb3JtYXRcbiAqIEBwYXJhbSB7Kn0gZm9ybWF0XG4gKiBAcGFyYW0geyp9IGRhdGVcbiAqIEByZXR1cm5zIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgZ2V0Rm9ybWF0dGVkRGF0ZSA9IChmb3JtYXQ6IHN0cmluZywgZGF0ZTogRGF0ZSk6IHN0cmluZyA9PiB7XG4gIGlmIChkYXRlKSB7XG4gICAgcmV0dXJuIG1vbWVudChkYXRlKS5mb3JtYXQoZm9ybWF0KTtcbiAgfVxuXG4gIHJldHVybiBtb21lbnQoKS5mb3JtYXQoZm9ybWF0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRKc29uU3RyaW5nID0gKHN0cjogc3RyaW5nKTogYW55ID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoc3RyLnRvU3RyaW5nKCkgPT09IFwibnVsbFwiKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG5jb25zdCBpc09iamVjdCA9IGZ1bmN0aW9uIChvYmo6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKSAmJiAhaXNBcnJheShvYmopICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIjtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gZnVuY3Rpb24gKGFycmF5OiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyYXkpO1xufTtcblxuY29uc3QgdG9DYW1lbCA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFstX11bYS16XSkvZ2ksICgkMSkgPT4ge1xuICAgIHJldHVybiAkMS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoXCItXCIsIFwiXCIpLnJlcGxhY2UoXCJfXCIsIFwiXCIpO1xuICB9KTtcbn07XG5cbi8vIGV4cG9ydCBjb25zdCBrZXlzVG9DYW1lbCA9IGZ1bmN0aW9uIChvYmo6IGFueSk6IGFueSB7XG4vLyAgIGlmIChpc09iamVjdChvYmopKSB7XG4vLyAgICAgY29uc3QgbiA9IHt9O1xuXG4vLyAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbi8vICAgICAgIG5bdG9DYW1lbChrZXkpXSA9IGtleXNUb0NhbWVsKG9ialtrZXldKTtcbi8vICAgICB9KTtcblxuLy8gICAgIHJldHVybiBuO1xuLy8gICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkge1xuLy8gICAgIHJldHVybiBvYmoubWFwKChpbmRleCkgPT4ge1xuLy8gICAgICAgcmV0dXJuIGtleXNUb0NhbWVsKGluZGV4KTtcbi8vICAgICB9KTtcbi8vICAgfVxuXG4vLyAgIHJldHVybiBvYmo7XG4vLyB9O1xuIl19